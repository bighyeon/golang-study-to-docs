### 2020-01-03 공부한 내용 Go언어 (가장 빨리 배우는 Go 언어 <- 서적) 
---

##### 1. 숫자 사용하기
---

###### 1.1 정수


int

>8진수는 숫자 앞에 0, 16진수는 앞에 0x or 0X를 붙인다.

---

###### 1.2 실수

float ex) var dd float32 = 0.1 or var d2 float64 = 0.2

>1. 실수를 정확하게 표현 불가능
>`실수는 무한히 많은데 이 실수를 유한개의 비트로 할라면 근사 값으로 표현해야해서` 
>2. 부동소수점 반올림 오차(Rounding error)를 사용함
>> ==을 사용하면 안됨. 연산한 값과 비교한 값의 차이를 구한 뒤 머신 입실론 보다 작거나 같은지 확인.
>>> const epsilon = 1e-14
>>> fmt.Println(math.Abs(a=9.0) <= epsilon)
>>> //값의 차이에서 음수가 나올 수 있으므로 절댓값을 넣는다.
>>> 
---


###### 1.3 복소수


complex64, complex128

>1. 복소수는 실수부 + 허수부 형태이며, 허수부에는 마지막에 i를 붙임.
>2. 실수부와 허수부는 고정소수점 및 부동소수점 형태로 표현.
>3. 복소수를 변수에 저장할 때 실수부 또는 허수부 생략 가능.
>4. real 함수는 복소수에서 실수부를 가져옴.
>5. imag함수는 허수부를 가져옴.
>

```

var num1 complex64 = 1 + 2i

var rl float32 = real(num1) // 실수부 1
var i1 float32 = imag(num1) // 허수부 2

var num1 complex64 = complex(1, 2) //+대신에 complex함수 사용 가능.

```
`복소수도 실수 형태이므로 계산했을 때 오차 발생.`

---

###### 1.4 바이트



byte
`var num1 byte = 10`

>1. 16진수, 문자 값을 저장.
>2. 실무에선 바이너리 파일에서 데이터 읽고 쓰거나, 데이터 암호화, 복호화할 때 주로 사용.
>3. 문자에 큰 따옴표 혹은 문자열은 저장할 수 없음. 컴파일 에러

---


###### 1.5 룬


rune
```
var r1 rune = '한'
var r2 rune = '\ud55c'
var r3 rune = '\U0000d55c'
```

>1. 유니코드(UTF-8) 문자 코드 저장할 때 사용.
>2. ' '로 묶어야하며, 문자 그대로 저장 혹은 \u, \U를 사용하여 문자코드 저장 가능
>> \U는 값을 16진수 8자리로 맞춰주어야함.

---


###### 1.6 숫자 연산

+, -, * , / , % , <<, >>, ^ 연산자 사용

>1. 자료형이 다르면 명시적으로 자료형을 반환해야함.
>2. 실수를 정수로 변환하면 소수점 이하 값 버려짐.
>3. 크기가 작은 자료형으로 변환하면 넘치는 값을 버리게 됨.
>

---


###### 1.7 오버플로우와 언더플로우


>자료형에서 저장할 수 있는 최대 크기 넘어서면 `오버플로우(Overflow)`
>최소 크기보다 작아지면 `언더플로우(Underflow)`


>math 패키지에 는 각 자료형의 최댓값이 준비되어있음.
>`MaxUint8, MaxUint16, MaxUint32, MaxUint64`등.
>>부호 없는 정수에 0을 대입하고, -1, 즉, 최솟값 그 밑이 나오면 언더플로우 발생.
>>최대값에 +1, 즉 최댓값 그 이상의 값이 나오면, 오버플로우가 발생함.
>>> GO에서는 이를 허용 하지 않고, 컴파일 에러 발생.
>>> 언더플로우 경우, 오버플로우 컴파일 에러가 발생함.

---


###### 1.8 변수의 크기 구하기



unsafe 패키지의 Sizeof 함수 사용.

>크기는 바이트 단위.
>

---


##### 2. 문자열 사용하기


string

> 1. " "로 묶어줘야 함.
> 2. UTF-8로 표현할 수 있는 문자 사용 가능.
> 3. 유니코드 문자코드로 저장 가능.
> 4. \x <- UTF-8 인코딩의 바이트 값을 그대로 저장할 때 사용.
> 5. 여러 줄로 된 문자열 저장할 때는 ` `(백쿼트)로 묶어줌.

```
var s7 string = `안녕하세요
Hello,world!`

```
---


###### 2.1 문자열 길이 구하기

len 함수를 사용.

>한글의 경우, '한글'은 2가 아닌 6으로 나옴.
>
>>UTF-8에 저장할 때, 한글은 3바이트(0xed, 0x95, 0x9c, 0xea, 0xb8, 0x80)으로 저장 되기 때문.

한글, 한자, 일본어 등 UTF-8로 저장했을 때 2바이트가 넘는 문자열의 길이를 구할땐
>unicode/utf8 패키지의 `RuneCountInString`함수를 사용함.
`fmt.Println(utf8.RuneCountInString('한글')//2로 출력`

---


###### 2.2 문자열 연산

비교 <- `==` 연산자 사용, 문자열 붙일 때 <- `+`연산자 사용

>문자열은 배열과 동일하게 [ ]로 각 문자를 가져올 수 있음. 0부터 시작.

```
var s1 string = "Hello"

fmt.Println("%c\n",s1[1]) // e출력

```

---


###### 2.3 문자열 수정

>문자열 저장 뒤 직접 내용 수정 불가능 

---


##### 3. 불(bool) 사용하기


> 참과 거짓 -> true, false 제공, 크기는 1바이트.
> AND(&&), OR(||), NOT(!) 논리 연산자 함께 사용.
> 비교 연산자도 함께 사용함.
> 

---

##### 4. 상수 사용하기


const 키워드 사용.
>고정된 값을 체계적으로 관리하고 싶을 때 사용.
>문자 또는 밑줄문자( _ )로 시작해야 하며, 숫자로 시작할 수 없음.
>반드시 선언과 동시에 초기화해야 하며 선언한 뒤에는 값을 변경할 수 없음.
`const 상수명 자료형 = 초깃값`


>자료형을 생략할 수 있음 -> 대입하는 값의 자료형으로 결정.
>상수를 여러개 선언하고 초기화할 때는 변수와 값을 ,(콤마)로 구분하여 나열.
```
const (
x, y int = 30, 50
age, name = 10, "Maria"
)
```
>>() 사용 가능.
>>

---


##### 5. 열거형 사용

상수 연속되는 값을 가질 때 사용.

```
const Sunday = 0

const Monday = 1

const Tuesday = 2

const Wednesday = 3

const Thurday = 4

const Friday = 5

const Saturday = 6

const numberOfDays = 7

```

=

```
const (

	Sunday = 0
	
	Monday = 1
	
	Tuesday = 2
	
	Wednesday = 3
	
	Thurday = 4
	
	Friday = 5
	
	Saturday = 6
	
	numberOfDays = 7

)



```
=

```
const (

	Sunday = iota //0 <-- 상수에 값을 일일이 대입하지 않고, 순서대로 생성 가능하게 하는게 iota
	
	Monday 
	
	Tuesday
	
	Wednesday
	
	Thurday
	
	Friday
	
	Saturday
	
	numberOfDays

)
```
> 1부터 시작하고 싶으면 iota + 1 하면 됨.
> iota에 연산자와 특정값을 조합하면 특정한 순서로 생성 가능.
> > 시프트 연산자, 곱셈 연산자 사용
> > 특정 iota 값 생략 할려면 ( _ )를 사용하면 됨.
> > 

---


##### 6. 연산자

1. `==`에서 슬라이스와 맵은 배열과는 달리 내용을 비교할 수 없고, 메모리에 할당되어 있는지 확인.
2. `<-`(채널수신연산) 채널에 값을 보내거나 값을 가져옴.
3. `+=, -=, *= . /=, %= , &=, |=, ^=, &^=, <<=, >>=`      -> 계산후 대입
4. `++`와 `--`는 go에선 사용한 뒤 값을 대입할 수 없고, 변수 뒤에서만 사용 가능. 따라서, ++연산자는 단독으로 사용하거나 if조건문, for 반복문 안에서 주로 사용.



| 우선순위 | 연산자           |
| -------- | ---------------- |
| 5        | * / % << >> & &^ |
| 4        | + - \| ^\|       |
| 3        | == != < <= > >=  |
| 2        | &&               |
| 1        | \|\|             |



>gofmt 도구로 소스 파일을 정렬했을 때 괄호가 없으면 연산자 우선수위가 높은 쪽의 공백을 삭제하여 서로 붙여줌
>> 우선순위가 같은 연산자만 있을 경우,  서로 붙이지 않고 모두 공백으로 띄어줌.


---


##### 7. 패키지 사용

import 키워드 사용.





###### 7.1 여러 패키지 사용

>>import 키워드가 많아지면 한번만 사용하고 패키지를 괄호로 묶어 사용 가능. ()
```
import (

	"fmt"
	
	"runtume"
)

```

---

###### 7.2 전역 패키지 사용



>패키지 이름 앞에 .(점)을 사용하면 전역 패키지가 됨.
>>현재 소스코드 안에서는 fmt.을 생략하고 fmt의 함수, 변수, 상수 사용 가능.
>>> 패키지 여러 개를 전역 패키지로 가져왔을 때, 함수와 변수, 상수 이름이 중복될 수 있음.
>>> 다른 사람이 읽을 때 이해를 못할 수 있음. 추천 하지 않음.

```
package main

import . "fmt"

func main(
	Println("Hello,World")
)

```

---


###### 7.3 패키지 별칭 사용

패키지 가져올 때 별칭 지정 가능.

```
package main

import f "fmt"

func main(
	f.Println("Hello,World")
)

```
>패키지 이름 앞에 별칭 붙여줄 수 있음.
>>Go에서 제공하는 기본 패키지와 내가 만든 패키지 중복, 혹은 다른 사람이 만든 패키지의 이름이 중복 될때 활용 가능.
>>


---

