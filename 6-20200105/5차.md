### 2020-01-05 공부한 내용 Go언어 (가장 빨리 배우는 Go 언어 <- 서적) 
---

##### 1. 배열 사용하기
---

Go 언어에서는 배열 길이가 고정 되어 있고, 배열 인덱스는 0부터 시작.

```
var a [5]int // int형 길이가 5인 배열 선언.

a[2] = 7    // 배열의 세 번째 요소에 7 대입.

fmt.Println(a)

```

배열 생성하면서 값을 초기화 하려면 자료형 뒤에`{}`를 붙이고 안에 값을 나열
>배열 선언할 때, 자료형과 길이는 생략 가능.
>:=를 사용하여 var 생략가능.

```
var a [5]int = 5[int]{22, 3, 5, 6, 7}

var b = [5]int{22, 3, 5, 6, 7}

c := [5]int{22, 3, 5, 6, 7}

```

>1. 중괄호에서 값은 한 줄 나열도 되고, 여러줄로 나열해도됨.
>2. 배열의 크기에 ...를 사용하면 초기화할 값의 개수에 따라 자동으로 크기 설정.
>
>> 여러줄로 나열할 때는 마지막 요소에도 콤마를 붙여줘야함.
>> 

```
a := [5]int{32, 22 , 3, 5, 6}

b := [5]int{

	32,
	
	22,
	
	3,
	
	5,
	
	6,
}

c := [...]int{32, 22, 3, 5, 6}


```

---


###### 1.1 배열 순회.


배열 길이만큼 반복하면서 요소 출력 방법

```
a := [5]int{32, 22 , 3, 5, 6}

for i := 0; i < len(a); i++ {

	fmt.Println(a[i])
}
```

배열 길이 구하지 않고 좀 더 간단하게 하는 방법 `range`키워드 사용.

```
a := [5]int{32, 22 , 3, 5, 6}

for i,value := range a { // i에는 인덱스, value에는 배열 요소의 값이 들어감.

	fmt.Println(i, value)
}
```


>인덱스 변수를 생략하면 첫 번째 리턴값인 인덱스만 들어가므로 주의.
>인덱스 변수는 생략하고, 값 변수만 사용하려면 다음과 같이 `_ (밑줄 문자)`를 사용
>> Go언어는 결괏값을 여러개 리턴할 수 있는 특징 존재.
>>
>> > 결괏값을 모두 받으려면 변수 개수를 맞춰야하고, 변수 없이 개수만 맞출 때, 밑줄 문자를 사용해야함.

---


###### 1.2 배열 복사

Go 언어의 배열 변수는 배열 전체를 뜻함. 첫 번째 요소의 포인터가 아님.
> 배열을 다른 변수에 대입하면 배열 전체가 복사됨.
> 

---

##### 2. 슬라이스 사용


1. 배열과 같지만 길이가 고정되어 있지 않음.
2. 동적으로 크기가 늘어남.
3. 배열과 달리 `레퍼런스`타입


`var a []int `

>1. 배열과 달리 길이를 지정하지 않음.
>2. 슬라이스는 `make`함수를 사용하여 공간 할당 후, 값을 넣을 수 있음.
>
>>슬라이스 선언과 동시에 `make`함수 사용하면 대괄호와 자료형 생략 가능
>> := 사용하여 var 생략 가능.
>> 

```
var a []int = make([]int, 5)

var b = make([]int, 5)

c := make([]int, 5)

```


>1. 슬라이스는 배열을 내장.
>2. 배열이 더 늘어났을 때 사용할 공간을 미리 할당할 수 있음.
   `var a =make([]int, 5, 10) //길이가 5이고 용량이 10인 슬라이스 생성.`

>1. 슬라이스 길이는 용량보다 크게 설정할 수 없음.
>2. 용량을 생략하면 용량은 길이와 동일하게 설정됨.
>3. 길이: 인덱스로 접근할 수 있는 공간.  <- 길이 이상의 인덱스에 접근하면 컴파일 에러 발생.
>4. 용량: 실제 메모리에 할당된 공간. <- 슬라이스에 요소를 추가하여 용량이 가득차면 용량 자동으로 늘어남.
>>1. 용량을 크게 할당하면 요소가 추가될 때마다 메모리를 새로 할당하지 않아도 되므로 성능 상 이점.
>>2. 처음부터 메모리 공간을 많이 차지한다는 단점 존재.
>>3. 슬라이스 용량을 적게 할당하면 처음부터 메모리 공간은 적게 차지.
>>4. 요소가 추가될 때마다 메모리를 새로 할당하게 되므로 성능이 떨어질 수 있음.
>>

슬라이스의 길이는 `len`함수로 구하고, 용량은 `cap`함수로 구함.



---



####### 2.1 슬라이스에 값 추가

`append`함수 사용
>슬라이스 맨 뒤에 값을 추가할 수 있음.
>
```
a := []int{1, 2, 3}

a = append(a, 4, 5, 6)

```

슬라이스에 다른 슬라이스 붙이려면 `append`함수 사용할 때 `...`을 사용.

```
a := []int{1, 2, 3}
b := []int{4, 5, 6}

a = append(a, b...)
```
> `append`함수는 가변인자 함수이므로 ... 사용하여 슬라이스에 들어 있는 요소를 각각 넘겨줌.
> ...은 가변인자 함수를 만들 때도 사용할 수 있고 가변인자 함수에 값을 넘겨줄 때도 사용.
> 

---


###### 2.2 레퍼런스 타입


슬라이스는 레퍼런스 타입. 
>내장된 배열에 대한 포인터이므로 슬라이스끼리 대입하면 값이 복사되지 않고 참조(레퍼런스)함.
>

```
a := []int{1, 2, 3}
var b []int

b = a
b[0] = 9

fmt.Println(a)
fmt.Println(b)

/// [9 2 3]으로 출력함.
```

>함수의 매배견수에 배열을 넘기면 복사가 되지만, 슬라이스 넘기면 참조만 하게 됨.
>

---


###### 2.3 슬라이스 복사

슬라이스의 요소를 모두 복사할 때는 copy함수 사용.

```
a := []int{1, 2, 3, 4, 5}
b := make([]int, 3)

copy(b, a) //슬라이스 a의 요소를 슬라이스 b에 복사

fmt.Println(a)
fmt.Println(b)

//결과 [1 2 3 4 5] [1 2 3]


```

>1. 공간을 할당하지 않은 빈 슬라이스에는 요소를 복사 할 수 없음.
>2. 길이가 3이므로 슬라이스 a 요소 3개만 복사됨.
>3. 슬라이스를 복사하였으므로 복사된 슬라이스의 요소를 바꿔도 원본 슬라이스는 바뀌지 않음.

---


###### 2.4 슬라이스와 용량


```
a := []int{1, 2, 3, 4, 5}

fmt.Println(len(a), cap(a)) // 5 5: 길이가 5이며, 용량도 5

a = append(a, 6, 7)

fmt.Println(len(a), cap(a)) // 7 10: 길이가 7이며 10인 슬라이스 용량 늘어남
```

>Go 언어는 동적 배열을 구현하기 위해 길이와 용량을 구분.
>>슬라이스 요소가 늘어나면 Go 런타임은 정해진 알고리즘에 의해 슬라이스의 용량 늘림.
>>

---


###### 2.5 부분 슬라이스 만들기

슬라이스는 기존 슬라이스에 일정 위치를 지정하여 부분 슬라이스 만들 수 있음.

```

a := int{1, 2, 3, 4, 5}

b := a[0:5]

```

>부분 슬라이스는 슬라이스의 시작 인덱스부터 끝 인덱스까지 일부만 참조.
>> 1. 끝 인덱스는 실제 인덱스보다 1 더 많음.
>> 2. 부분 슬라이스를 만들더라도 슬라이스의 요소는 복사되지 않으므로 부분 슬라이스 내용 바꾸면 기존 슬라이스 내용도 바뀜.


```
a := []int{1, 2, 3, 4, 5}

fmt.Println(a[:]) // [1 2 3 4 5]
fmt.Println(a[0:]) // [1 2 3 4 5]
fmt.Println(a[:5]) // [1 2 3 4 5]
fmt.Println(a[0:len(a)]) // [1 2 3 4 5]

fmt.Println(a[3:]) // [4 5]
fmt.Println(a[:3])    // [1 2 3]
fmt.Prontln(a[1:2])   // [2 3]
```
> 1. 부분 슬라이스 생성할 때, 시작 인덱스와 끝 인덱스는 생략 가능
> 2. 시작 인덱스 생략하면 0으로 지정, 끝 인덱스 생략하면 슬라이스의 길이 들어감.
> 3. 부분 슬라이스는 슬라이스뿐만 아니라 배열에도 사용 가능 
>
> > 이때 참조이기 때문에 배열이라도 부분 슬라이스의 요소 바꾸면 배열 요소 바뀜.
> > 


부분 슬라이스 만들면서 용량도 함께 지정 가능.

```
a := []int{1, 2, 3, 4, 5, 6, 7, 8}

b := a[0:6:8] //인덱스 0부터 6까지 가져와서 부분 슬라이스 만들고 용량을 8로 설정

```

>용량 설정할 때, 기존 슬라이스의 용량을 넘을 수 는 없음.

```

```